# denoizing_classification_audio
<p>Репозиторий состоит из jupyter ноутбука, 2-х папок с моделями и питоновского файла с модулем для инференса моделей.
<p>Описание использованных алгоритмов:
<p>Задача 1:
<p>Необходимо написать программу с функцией multiplicate(A), принимающей на вход массив целых чисел А ненулевой длины и массив такой же длины, в котором на i-ом месте находится произведение всех чисел массива А, кроме числа, стоящего на i-ом месте.
<p>Решение:
<p>1. Перемножаем все числа в массиве, результат кладем в переменную (А)
<p>2. Идем по массиву, делим результат умножения (А) на текущее число
<p>Важно учитывать кейсы с 1-м и 2-мя нулями отдельно
<p>Задача 2.1:
<p>Необходимо реализовать алгоритм, позволяющий определить, является ли аудиозапись зашумлённой или нет. 
<p>Решение:
<p>Задача бинарной классификации. Берем данные, приводим к одной длинне (добивая нулями), учим классификатор на основе сверточной нейронной сети с softmax или sigmoid активацией в конце и BCE loss функцией.
<p>Задача 2.2:
<p>необходимо реализовать алгоритм, позволяющий избавиться от посторонних шумов в звуковом сигнале. 
<p>Решение:
<p>Для решения этой задачи я использовал нейронную сеть архитектуры UNET т.к. она довольно хорошо зарекомендовала себя для подобного рода задач. Главная фишка модели - это skip connections. За счет них модель использует как данные с первых слоев сети, так и с последних для преобразования, что позволяет получить более полезные признаки.  Так же это помогает в борьбе с недообучением первых слоев сети. Визуализация архитектуры есть в jupyter notebook'e. 

<p>Для запуска и проверки моделей, используйте файл inference.py
<p>Пример:
<p> python3 inference.py -m=./val/val/noisy/1084/1084_139230_1084-139230-0002.npy -rresult_path='.'
