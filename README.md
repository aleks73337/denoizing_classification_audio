# denoizing_classification_audio
Репозиторий состоит из jupyter ноутбука, 2-х папок с моделями и питоновского файла с модулем для инференса моделей.
Описание использованных алгоритмов:
Задача 1:
Необходимо написать программу с функцией multiplicate(A), принимающей на вход массив целых чисел А ненулевой длины и массив такой же длины, в котором на i-ом месте находится произведение всех чисел массива А, кроме числа, стоящего на i-ом месте.
Решение:
1. Перемножаем все числа в массиве, результат кладем в переменную (А)
2. Идем по массиву, делим результат умножения (А) на текущее число
Важно учитывать кейсы с 1-м и 2-мя нулями отдельно
Задача 2.1:
необходимо реализовать алгоритм, позволяющий определить, является ли аудиозапись зашумлённой или нет. 
Решение:
Задача бинарной классификации. Берем данные, приводим к одной длинне (добивая нулями), учим классификатор на основе сверточной нейронной сети с softmax или sigmoid активацией в конце и BCE loss функцией.
Задача 2.2:
необходимо реализовать алгоритм, позволяющий избавиться от посторонних шумов в звуковом сигнале. 
Решение:
Для решения этой задачи я использовал нейронную сеть архитектуры UNET т.к. она довольно хорошо зарекомендовала себя для подобного рода задач. Главная фишка модели - это skip connections. За счет них модель использует как данные с первых слоев сети, так и с последних для преобразования, что позволяет получить более полезные признаки.  Так же это помогает в борьбе с недообучением первых слоев сети. Визуализация архитектуры есть в jupyter notebook'e. 

Для запуска и проверки моделей, используйте файл inference.py
Пример:
python3 inference.py -m=./val/val/noisy/1084/1084_139230_1084-139230-0002.npy -rresult_path='.'
